<head>
    <meta charset="UTF-8">
    <!--  make sure all devices can work instead of using default settings -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/adsense.js"></script>
    <title> How Makefiles Are Remade  </title>
</head>
<body>
<p>
If a makefile can be remade from other files, you probably want make to get an up-to-date version of the
makefile to read in; To this end, after reading in all makefiles make will consider each as a goal target, in
the order in which they were processed, and attempt to update it.

<p>
If a makefile has a rule which says how to update it (found either in that very makefile
or in another one) or if an implicit rule applies to it, it will be updated if necessary.

<p>
After all makefiles have been checked, if any have actually been changed, make reads all the makefiles over again;
Each restart will cause the special variable MAKE_RESTARTS to be updated.


<p>
If you know that one or more of your makefiles cannot be remade(perhaps for efficiency reasons), you
can use any normal method of preventing implicit rule look-up to do so. For example,
you can write an explicit rule with the makefile as the target, and an empty recipe

<p>make will not attempt to remake makefiles which are specified as targets of a double-colon rule with a recipe but
no prerequisites, because:<pre style=font-style:italic>
A double-colon target file which is a makefile will always be remade when that double-colon rule has a recipe but
no prerequisites, this would cause an infinite loop
</pre>

<p>make will not attempt to remake makefiles which are marked phony, because:<pre style=font-style:italic>
 Phony targets are also never considered up-to-date, so an included makefile marked as phony would cause make to restart continuously.
</pre>

<p>You can take advantage of this to optimize startup time: if you know you don’t need
your Makefile to be remade you can prevent make from trying to remake it by adding
either:<br>
.PHONY: Makefile<br>
or <br>
Makefile:: ;

<p>If you do not specify any makefiles to be read with ‘-f’ or ‘--file’ options, make will try the default makefile names;
Unlike makefiles explicitly requested with ‘-f’ or ‘--file’ options, make is not certain that these makefiles should exist.
if none of the default makefiles exists, make will try to make each of them until it succeeds in making one, or it runs out of names to try.
Note that it is not an error if make cannot find or make any makefile, <b style=color:red>as a makefile is not always necessary(If make can't find any makefile, you must specify
a goal with a command argument, and make will attempt to figure out how to remake it
using only its built-in implicit rules)</b>

<p>When you use the ‘-t’ or ‘--touch’ option, you would not want to use an out-of-date makefile to decide which targets to
touch. So the ‘-t’ option has no effect on updating makefiles; they are really updated even
if ‘-t’ is specified. Likewise, ‘-q’ (or ‘--question’) and ‘-n’ (or ‘--just-print’) do not
prevent updating of makefiles, because an out-of-date makefile would result in the wrong
output for other targets. Thus, ‘make -f mfile -n foo’ will update mfile, read it in, and
then print the recipe to update foo and its prerequisites without running it. The recipe
printed for foo will be the one specified in the updated contents of mfile.

<p>However, on occasion you might actually wish to prevent updating of even the makefiles.
You can do this by specifying the makefiles as goals in the command line as well as specifying
them as makefiles. When the makefile name is specified explicitly as a goal, the options ‘-t’
and so on do apply to them. Thus, ‘make -f mfile -n mfile foo’ would read the makefile mfile, print the recipe
needed to update it without actually running it, and then print the recipe needed to update
foo without running that. The recipe for foo will be the one specified by the existing
contents of mfile.